#!/usr/bin/env ruby

require 'rubygems'

begin
  require 'taketo'
  require 'taketo/constructs_factory'
  require 'taketo/commands'
  require 'taketo/destination_resolver'
  require 'optparse'
rescue LoadError => e #development
  raise if $loaded
  $:.unshift File.expand_path('../../lib', __FILE__)
  require 'bundler'
  Bundler.setup(:default)
  $loaded = true
  retry
end

Signal.trap("SIGINT") do
  puts "Terminating"
  exit 1
end

include Taketo

DEFAULT_CONFIG_FILE = File.join(ENV['HOME'], ".taketo.rc.rb")

def parse_options
  options = { :config => DEFAULT_CONFIG_FILE }

  OptionParser.new do |opts|
    opts.banner = "Usage: taketo [destination] [options]"
    opts.version = VERSION
    opts.separator ""
    opts.separator "Common options:"

    opts.on("-f CONFIG", "--config", "Use custom config file (default: #{DEFAULT_CONFIG_FILE})") do |c|
      options[:config] = c
    end

    opts.on("-c COMMAND", "--command", "Command to execute on destination server", 
            "  (COMMAND either declared in config or passed as an argument)") do |c|
      raise OptionParser::MissingArgument if String(c).strip.empty?
      options[:command] = c
    end

    opts.on("-d DIRECTORY", "--directory", "Directory on destination server to cd to") do |d|
      raise OptionParser::MissingArgument if String(d).strip.empty?
      options[:directory] = d
    end

    opts.on("-v", "--view", "Show config contents and exit") do |v|
      options[:view] = v
    end

    opts.separator "Special options:"

    opts.on("--dry-run", "Print out what would be run") do |v|
      options[:dry_run] = v
    end

    opts.on("--debug") do |d|
      options[:debug] = d
    end

  end.parse!

  options
end

def parse_config(config)
  DSL.new.configure(config).tap do |config|
    ConfigValidator.new(config).validate!
  end
end

def remote_command(server, options)
  command_name = options[:command] or return default_command(options)
  server.find(:command, command_name.to_sym) { default_command(options) }
end

def default_command(options)
  cmd = Constructs::Command.new(:default)
  cmd.command = options.fetch(:command) { "bash" }
  cmd
end
 
begin
  options          = parse_options
  config           = parse_config(options[:config])
  destination_path = ARGV.shift.to_s
  resolver         = DestinationResolver.new(config, destination_path)

  if options.delete(:view)
    node = resolver.get_node
    puts ConfigPrinter.new.render(node).chomp
  else
    server = resolver.resolve

    server_command = remote_command(server, options)
    command_to_execute = Commands::SSHCommand.new(server).render(server_command.render(server, options))

    if options[:dry_run]
      puts command_to_execute
    else
      system command_to_execute
    end
  end
rescue SystemExit
  # Do nothing
rescue Exception => e
  STDERR.puts "An error occurred: #{e.message}"
  raise if options && options[:debug]
end

